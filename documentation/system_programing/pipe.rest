.. vim: syntax=rst

管道
--

本章节内容处于开发笔记状态，还待整理至最终版的教程。

本章节内容处于开发笔记状态，还待整理至最终版的教程。

管道的基本概念
~~~~~~~

在进入正式的学习之前，想一想管道为什么叫管道，也想一想生活中有什么跟管道相关的？比如水管，水通过水管从一端流向另一端，那么进程间通信是不是可以模仿这种“流向”的关系呢，很显然是可以的，数据可以从一个进程流向另一个进程，那么一个进程产生数据，然后通过管道发送给另一个进程，另一个进程读取到数据，这样一来
就实现了进程间的通信了。

在上一章中，我们学过信号，一个信号从进程中产生，发送给另一个进程，这其实也是信号类型的通信，只传递信号值，而没有数据传递，就会在很多时候无法满足我们的需求，因此管道的传输数据功能就会在某些场合非常适用。

我们可以首先做个试验，在终端中使用以下命：

命令

ps -aux \| grep root

输出

root 1 0.0 0.0 225376 6376 ? Ss 10月18 0:31 /sbin/init

root 2 0.0 0.0 0 0 ? S 10月18 0:00 [kthreadd]root 4 0.0 0.0 0 0 ? I< 10月18 0:00 [kworker/0:0H]root 6 0.0 0.0 0 0 ? I< 10月18 0:00 [mm_percpu_wq]root 7
0.0 0.0 0 0 ? S 10月18 0:02 [ksoftirqd/0]root 8 0.0 0.0 0 0 ? I 10月18 5:35 [rcu_sched]root 9 0.0 0.0 0 0 ? I 10月18 0:00 [rcu_bh]root 10 0.0 0.0 0 0 ? S
10月18 0:00 [migration/0]root 11 0.0 0.0 0 0 ? S 10月18 0:01 [watchdog/0]root 12 0.0 0.0 0 0 ? S 10月18 0:00 [cpuhp/0]root 13 0.0 0.0 0 0 ? S 10月18 0:00
[cpuhp/1]

首先ps命令我们是非常熟悉的了，就是列出当前的进程，grep命令我们也使用过，它是一种强大的文本搜索工具，它能使用正则表达式搜索文本，那么ps与grep命令之间的“|”符号是什么呢？它其实是一个管道，将ps命令输出的数据通过管道流向grep，其实在这里就打开了两个进程，ps命令本应该在终端输出信息的
，但是它通过管道将输出的信息作为grep命令的输入信息，然后通过搜索之后将合适的信息显示出来，这样子就形成了我们在终端看到的信息。

读者可以验证是否打开了两个进程，使用以下命令查看当前的进程情况，一定会在输出的最后打印两个进程相关的信息（ps、grep）：

命令

ps -ux \| grep $USER

输出（在输出的最后）

xxx 29663 0.0 0.0 29580 1460 pts/0 R+ 07:12 0:00 ps -ux

xxx 29664 0.0 0.0 14888 1016 pts/0 S+ 07:12 0:00 grep --color=auto xxx

什么是管道呢？当从一个进程连接数据流到另一个进程时，这就是一个管道（pipe）。我们通常是把一个进程的输出通过管道连接到另一个进程的输入。对于shell命令来说，命令的连接是通过管道字符来完成的，正如“ps -aux \| grep root”命令一样，只需要使用“|”字符进行连接即可。

那么我们对这个“ps -aux \| grep root”命令进行详细的分析，它实际上就是执行以下过程：

-  shell负责安排两个命令的标准输入和标准输出。

-  ps的标准输入来自终端鼠标、键盘等。

-  ps的标准输出传递给grep，作为它的标准输入。

-  grep的标准输出连接到终端显示器屏幕时。

shell所做的工作实际上是对标准输入和标准输出流进行了重新连接，使数据流从键盘输入通过两个命令最终输出到屏幕上，示意图具体见图 39‑1。

|pipe002|

图 39‑1 管道连接示意图

其实，管道本质上是一个文件，图 39‑1过程可以看做是ps进程将输出的内容写入管道中，grep进程从管道中读取数据，这样子就是一个可读可写的文件，这其实也遵循了linux中“一切皆文件”的设计思想，因此linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。不过还是要注意的是
：虽然管道的实现形态上是文件，但是管道本身并不占用磁盘或者其他外部存储的空间，它占用的是内存空间，因此linux上的管道就是一个操作方式为文件的内存缓冲区。

管道的分类
~~~~~

Linux系统上的管道分两种类型：

-  匿名管道

-  命名管道

这两种管道也叫做无名或有名管道，为了统一，作者还是使用匿名管道和有名管道。匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，
以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。这保证了传输数据的安全性，当然也降低了管道了通用性，于是系统还提供了命名管道，它本质是一个文件，位于文件系统中，命名管道可以让多个无相关的进程进行通讯。

匿名管道PIPE
^^^^^^^^

匿名管道（PIPE）是一种特殊的文件，但虽然它是一种文件，却没有名字，因此一般进程无法使用open()来获取他的描述符，它只能在一个进程中被创建出来，然后通过继承的方式将他的文件描述符传递给子进程，这就是为什么匿名管道只能用于亲缘关系进程间通信的原因。另外，
匿名管道不同于一般文件的显著之处是：它有两个文件描述符，而不是一个，一个只能用来读，另一个只能用来写，这就是所谓的“半双工”通信方式。而且它对写操作不做任何保护，即：假如有多个进程或线程同时对 匿名管道进行写操作，那么这些 数据很有可能会相互践踏，因此一个简单的结论是：
匿名管道只能用于一对一的亲缘进程通信。最后， 匿名管道不能使用 lseek()来进行所谓的定位，因为他们的数据不像普通文件那样按块的方式存放在诸如硬盘、 flash 等块设备上。

总结来说，匿名管道有以下的特征：

1. 没有名字，因此不能使用open()函数打开，但可以使用close()函数关闭。

2. 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程1往文件内写东西，那么进程2 就只能读取文件的内容。

3. 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信 。

4. 管道是基于字节流来通信的 。

5. 依赖于文件系统，它的生命周期随进程的结束而结束。

6. 写入操作不具有原子性，因此只能用于一对一的简单通信情形。

7. 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read()和 write()等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek()来定位。

命名管道FIFO
^^^^^^^^

命名管道（FIFO）与匿名管道（PIPE）是不同的，命名管道可以在多个无关的进程中交换数据（通信）。我们知道，匿名管道的通信方式通常都由一个共同的祖先进程启动，只能在“有血缘关系”的进程中交互数据，这给我们在不相关的的进程之间交换数据带来了不方便，因此产生了命名管道，来解决不相关进程间的通信问题。

命名管道不同于无名管道之处在于它提供了一个路径名与之关联，以一个文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在“血缘关系”的进程，只要可以访问该命名管道文件的路径，就能够彼此通过
命名管道相互通信，因为可以通过文件的形式，那么就可以调用系统中对文件的操作，如打开（open）、读（read）、写（write）、关闭（close）等函数，虽然命名管道文件存储在文件系统中，但数据却是存在于内存中的，这点要区分开。

总结来说，命名管道有以下的特征：

1. 有名字，存储于普通文件系统之中。

2. 任何具有相应权限的进程都可以使用 open()来获取命名管道的文件描述符。

3. 跟普通文件一样：使用统一的 read()/write()来读写。

4. 跟普通文件不同：不能使用 lseek()来定位，原因是数据存储于内存中。

5. 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。

6. 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。

pipe()函数
~~~~~~~~

pipe()函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。我们可以通过man命令查看pipe函数的相关介绍：

命令

man pipe

输出（已删减）

头文件

#include <unistd.h>

函数原型

int pipe(int pipefd[2]);

函数原型非常简单，没有任何的传入参数，注意：数组pipefd是用于返回两个引用管道末端的文件描述符，它是一个由两个整数类型的文件描述符组成的数组的指针。 pipefd [0] 指管道的读取端， pipefd
[1]指向管道的写端。向管道的写入端写入数据将会由内核缓冲，即写入内存中，直到从管道的读取端读取数据为止，而且数据遵循先进先出原则。pipe()函数还会返回一个int类型的变量，如果为0则表示创建匿名管道成功，如果为-1则表示创建失败，并且设置errno。

匿名管道创建成功以后，创建该匿名管道的进程（父进程）同时掌握着管道的读取端和写入端，但是想要父子进程间有数据交互，则需要以下操作：

1. 父进程调用pipe()函数创建匿名管道，得到两个文件描述符pipefd [0]、pipefd [1]，分别指向管道的读取端和写入端。

2. 父进程调用fork()函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符pipefd [0]、pipefd [1]，它们指向同一匿名管道的读取端与写入端。

3. 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，示意图如图 39‑2所示，因此需要进行接下来的操作。

4. 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，示意图如图 39‑3所示。

5. 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，示意图如图 39‑4所示。

6. 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。

|pipe003|

图 39‑2 fork()后子进程继承父进程文件描述符

|pipe004|

图 39‑3 数据从父进程流向子进程

|pipe005|

图 39‑4 数据从子进程流向父进程

我们可以使用pipe()函数做一个测试实验，野火资料提供了对应的实验代码，在application/pipe目录下存在pipe.c文件，该文件内容如代码清单 39‑1所示。

代码清单 39‑1 pipe.c源码文件内容

1 #include <unistd.h>

2 #include <sys/types.h>

3 #include <sys/wait.h>

4 #include <errno.h>

5 #include <stdio.h>

6 #include <stdlib.h>

7 #include <string.h>

8

9 #define MAX_DATA_LEN 256

10 #define DELAY_TIME 1

11

12 int main()

13 {

14 pid_t pid;

15 int pipe_fd[2]; **(1)**

16 char buf[MAX_DATA_LEN];

17 const char data[] = "Pipe Test Program";

18 int real_read, real_write;

19

20 memset((void*)buf, 0, sizeof(buf));

21

22 /\* 创建管道 \*/

23 if (pipe(pipe_fd) < 0) { **(2)**

24 printf("pipe create error\n");

25 exit(1);

26 }

27

28 /\* 创建一子进程 \*/

29 if ((pid = fork()) == 0) { **(3)**

30 /\* 子进程关闭写描述符，并使子进程暂停 3s 等待父进程已关闭相应的读描述符 \*/

31 close(pipe_fd[1]);

32 sleep(DELAY_TIME \* 3);

33

34 /\* 子进程读取管道内容 \*/ **(4)**

35 if ((real_read = read(pipe_fd[0], buf, MAX_DATA_LEN)) > 0) {

36 printf("%d bytes read from the pipe is '%s'\n", real_read, buf);

37 }

38

39 /\* 关闭子进程读描述符 \*/

40 close(pipe_fd[0]); **(5)**

41

42 exit(0);

43 }

44

45 else if (pid > 0) {

46 /\* 父进程关闭读描述符，并通过使父进程暂停 1s 等待子进程已关闭相应的写描述符 \*/

47 close(pipe_fd[0]); **(6)**

48

49 sleep(DELAY_TIME);

50 **(7)**

51 if ((real_write = write(pipe_fd[1], data, strlen(data))) != -1) {

52 printf("Parent write %d bytes : '%s'\n", real_write, data);

53 }

54

55 /*关闭父进程写描述符*/

56 close(pipe_fd[1]); **(8)**

57

58 /*收集子进程退出信息*/

59 waitpid(pid, NULL, 0); **(9)**

60

61 exit(0);

62 }

63 }

代码清单 39‑1\ **(1)**\ ：定义一个数组pipe_fd，在创建匿名管道后通过数组返回管道的文件描述符。

代码清单 39‑1\ **(2)**\ ：调用pipe()创建一个匿名管道，创建成功则得到两个文件描述符pipe_fd[0]、pipe_fd[1]，否则返回-1。

代码清单 39‑1\ **(3)**\ ：调用fork()创建一个子进程，如果返回值是0则表示此时运行的是子进程，那么在子进程中调用close()函数关闭写描述符，并使子进程睡眠 3s 等待父进程已关闭相应的读描述符。

代码清单 39‑1\ **(4)**\ ：子进程调用read()函数读取管道内容，如果管道没有数据则子进程将被阻塞，读取到数据就将数据打印出来。

代码清单 39‑1\ **(5)**\ ：调用close()函数关闭子进程读描述符。

代码清单 39‑1\ **(6)**\ ：如果fork()函数的返回值大于0，则表示此时运行的是父进程，那么在父进程中先调用close()关闭管道的读描述符，并且等待1s，因为此时可能子进程先于父进程运行，暂且等待一会。

代码清单 39‑1\ **(7)**\ ：父进程调用write()函数将数据写入管道。

代码清单 39‑1\ **(8)**\ ：关闭父进程写描述符。

代码清单 39‑1\ **(9)**\ ：调用waitpid()函数收集子进程退出信息并退出进程。

我们使用make命令编译，然后运行“targets”程序，其运行结果如图 39‑5所示：

|pipe006|

图 39‑5 pipe()函数测试结果

我们再深入学习一下pipe管道的一些知识吧，比如：当没有数据可读时，调用read()函数读取数据时通常会阻塞，即它将暂停进程来等待直到有数据到达为止。但如果管道的另一端已被关闭，也就是说，已经没有进程打开这个管道并向它写数据了，这时调用read()函数如果会阻塞的话，就没有意义，因为这个进程永远不会
等待到数据，这也是匿名管道的一个特性，它只能在创建时返回对应的文件描述符，而无法在关闭文件描述符后后再通过open()这类函数打开，因此对一个已关闭写数据的管道做read()调用将返回0而不是阻塞。这就使读进程能够像检测文件结束一样，对管道进行检测并作出相应的动作。注意，这与read()函数读取一个
无效的文件描述符不同， read()函数会把无效的文件描述符看作一个错误并返回-1。

fifo()函数
~~~~~~~~

至此，我们还只能在有“血缘关系”的程序之间传递数据，即这些程序是由一个共同的祖先进程启动的。但如果我们想在不相关的进程之间交换数据，这还不是很方便，我们可以用FIFO文件来完成这项工作，或者称之为命名管道。命名管道是一种特殊类型的文件，它在文件系统中以文件名的形式存在，但它的的数据却是存储在内存中的
。我们可以在终端（命令行）上创建命名管道，也可以在程序中创建它。

比如使用

.. |pipe002| image:: media/pipe002.png
   :width: 5.76806in
   :height: 1.89043in
.. |pipe003| image:: media/pipe003.png
   :width: 5.76806in
   :height: 3.97056in
.. |pipe004| image:: media/pipe004.png
   :width: 5.76806in
   :height: 4.00706in
.. |pipe005| image:: media/pipe005.png
   :width: 5.76806in
   :height: 4.24902in
.. |pipe006| image:: media/pipe006.png
   :width: 5.76806in
   :height: 2.49682in
